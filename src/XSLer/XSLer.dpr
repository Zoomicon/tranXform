(*******************************************************************
 XSLer - transform an XML file using an XSL stylesheet
 (C)2001 George Birbilis <birbilis@kagi.com>
 Agrinio Club (http://visitweb.com/AgrinioClub)
 Version: 13Sep2001

 Command line tool that takes 3 params: XMLfile XSLfile outputFile
 XMLFile and XSLfile paths are either absolute, or else relative to the current folder, 
 or else (final try if file not found) relative to the executable's location

 note: must use standalone="no" at the XML header (the 1st XML line)
********************************************************************)

program XSLer;
//{$APPTYPE CONSOLE} - don't show a console window (can run from the DOS prompt if want a to see a console window)
uses
  classes,
  SysUtils,
  Windows,
  ActiveX,
  MSXML_TLB_Birb;

{$R *.RES}

resourcestring
 sNoDOM     = 'Couldn''t create the DOM';
 sNoOutput  = 'Nothing generated by the transformation';
 sSyntax    = 'XSLer takes 3 params: XMLfile XSLfile outputFile'+#13+
              'XMLfile and XSLfile paths are either absolute, or else relative to the'+#13+
              'current folder or else (final try) relative to the executable''s location';

var
 appPath:string;
 iddXML: IXMLDOMDocument;
 iddXSL: IXMLDOMDocument;

{Instantiate the DOMs}
procedure CreateDOMs;
var hRes:HResult;
begin
 CoInitialize(nil);
 hRes := CoCreateInstance(CLASS_DOMDocument, nil,
          CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument, iddXML);
 if hRes <> S_OK then
  raise Exception.Create(sNoDOM);
 hRes := CoCreateInstance(CLASS_DOMDocument, nil,
          CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument, iddXSL);
 if hRes <> S_OK then
  raise Exception.Create(sNoDOM);
end;

{Release the DOMs}
procedure DestroyDOMs;
begin
 iddXML := nil;
 iddXSL := nil;
 CoUninitialize;
end;

procedure error(reason:string);
begin
 MessageBox(0,pchar(reason), 'Syntax error!', MB_IconError+MB_OK);
end;

function formatXMLerror(err:IXMLDOMParseError):string;
begin
 with err do
  result:=format('%s'+#13+'url=%s'+#13+'line=%d',[reason, url, line]);
end;

procedure loadXML;
var inpath:string;
begin
 inpath:=expandFileName(paramStr(1));
 if not fileExists(inpath) then inpath:=appPath+paramStr(1);
 if not iddXML.Load(inpath) then
  raise Exception.create(formatXMLerror(iddXML.ParseError));
end;

procedure loadXSL;
var inpath:string;
begin
 inpath:=expandFileName(paramStr(2));
 if not fileExists(inpath) then inpath:=appPath+paramStr(2);
 if not iddXSL.Load(inpath) then
  raise Exception.create(formatXMLerror(iddXML.ParseError));
end;

{Apply the stylesheet to the data and save the results}
procedure transform;
var
  sOutput: string;
  stmOut: TFileStream;
  stmString: TStringStream;
  outPath: string;
begin
 outPath:=expandFileName(paramStr(3));

 {Combine the XML with the XSL}
 sOutput := iddXML.documentElement.parentNode.transformNode(iddXSL);
 if sOutput = '' then
  raise Exception.Create(sNoOutput);

 {Save to the output file}
 try
  stmOut:=TFileStream.Create(outPath, fmCreate);
  stmString:=TStringStream.Create(sOutput);
  stmOut.CopyFrom(stmString, 0);
 finally
  stmOut.Free; //may see a warning here that "Variable 'stmOut' might have not been initialized" (shouldn't show that warning: Free is a static class method)
  stmString.Free; //may see a warning here that "Variable 'stmString' might have not been initialized" (shouldn't show that warning: Free is a static class method)
 end;
end;

begin
 if(paramCount<>3) then
  begin
  error(sSyntax);
  halt(1);
  end;
 appPath:=ExtractFilePath(paramStr(0));
 try
  createDOMs;
  loadXML;
  loadXSL;
  transform;
 except
  on e:Exception do
   begin
   error(e.message);
   destroyDOMs;
   halt(2);
   end;
 end;
 destroyDOMs;
end.

